# 일정 서비스 - AI 기반 일정 생성 내부 시퀀스

## 시나리오 개요
- **시나리오명**: ai-itinerary-generation  
- **주요 API**: POST /api/itinerary/trips/{tripId}/itineraries (generateItinerary)
- **유저스토리**: RQ-ITIN-001 - 멤버 특성을 고려한 시간대별 상세 일정을 자동으로 생성
- **처리 방식**: 비동기 Job Queue 기반 AI 일정 생성

## PlantUML 시퀀스 다이어그램

```plantuml
@startuml
!theme mono

title 일정 서비스 - AI 기반 일정 생성 내부 시퀀스

actor Client as "클라이언트"
participant ItineraryController as "일정\n컨트롤러"
participant ItineraryService as "일정\n서비스"
participant ProfileCacheService as "프로파일\n캐시서비스"
participant AIEngine as "AI\n엔진"
participant SagaOrchestrator as "사가\n오케스트레이터" 
participant JobQueue as "작업\n큐"
participant LocationJobProducer as "장소작업\n생산자"
participant ItineraryWriteRepo as "일정쓰기\n저장소"
participant ItineraryReadRepo as "일정읽기\n저장소"
participant RedisCache as "Redis\n캐시"
database WriteDB as "쓰기\nDB"
database ReadDB as "읽기\nDB"

== 1. 일정 생성 요청 수신 ==

Client -> ItineraryController : POST /api/itinerary/trips/{tripId}/itineraries
note right
  요청 데이터:
  - 생성할 날짜
  - 추가 요구사항 (자연어)
  - 일정 생성 선호 옵션
end note

ItineraryController -> ItineraryService : generateItinerary(tripId, request)

== 2. 요청 검증 및 프로파일 캐시 조회 ==

ItineraryService -> ItineraryService : validateRequest(request)
note right
  비즈니스 검증:
  - 날짜 유효성 (미래 날짜)
  - 시간 설정 일관성
  - 여행 기간 내 날짜인지 확인
end note

ItineraryService -> ProfileCacheService : getMemberProfiles(tripId)
ProfileCacheService -> RedisCache : get("profile:member:" + tripId)

alt 캐시 히트
    RedisCache --> ProfileCacheService : 멤버 프로파일 데이터
else 캐시 미스
    ProfileCacheService -> ProfileCacheService : [외부 호출] Profile Service API
    ProfileCacheService -> RedisCache : set("profile:member:" + tripId, data, ttl=3600)
    RedisCache --> ProfileCacheService : 저장 완료
end

ProfileCacheService --> ItineraryService : 멤버 특성 정보

ItineraryService -> ProfileCacheService : getTripBasicInfo(tripId)
ProfileCacheService -> RedisCache : get("profile:trip:" + tripId)

alt 캐시 히트
    RedisCache --> ProfileCacheService : 여행 기본정보 데이터
else 캐시 미스
    ProfileCacheService -> ProfileCacheService : [외부 호출] Profile Service API  
    ProfileCacheService -> RedisCache : set("profile:trip:" + tripId, data, ttl=3600)
end

ProfileCacheService --> ItineraryService : 여행 기본정보

== 3. AI 엔진 초기화 및 일정 생성 준비 ==

ItineraryService -> AIEngine : initializeAIContext(memberProfiles, tripInfo, additionalRequirements)
note right
  AI 컨텍스트 구성:
  - 멤버 나이/건강상태 고려 강도 조절
  - 선호사항 기반 장소 카테고리 가중치
  - 자연어 요구사항 분석
  - 식사시간/휴식시간 자동 배치
end note

AIEngine -> AIEngine : analyzeUserRequirements(additionalRequirements)
AIEngine -> AIEngine : calculateItineraryIntensity(memberProfiles)
AIEngine --> ItineraryService : AI 컨텍스트 준비 완료

== 4. 사가 패턴 기반 분산 트랜잭션 시작 ==

ItineraryService -> SagaOrchestrator : startItineraryGenerationSaga(sagaContext)
note right
  사가 컨텍스트:
  - tripId, date
  - 멤버 프로파일
  - AI 컨텍스트
  - 보상 트랜잭션 정보
end note

SagaOrchestrator -> SagaOrchestrator : createSagaTransaction(ITINERARY_GENERATION)

== 5. 비동기 장소 검색 작업 큐 발송 ==

SagaOrchestrator -> LocationJobProducer : enqueueLocationSearchJobs(searchCriteria)
note right
  검색 조건들:
  - 관광지 검색 (선호도 기반)
  - 식당 검색 (식사 시간대별)
  - 카페 검색 (휴식 시간용)
  - 교통 정보 조회
end note

LocationJobProducer -> JobQueue : 관광지 검색 작업
LocationJobProducer -> JobQueue : 식당 검색 작업  
LocationJobProducer -> JobQueue : 카페 검색 작업
LocationJobProducer -> JobQueue : 교통정보 조회 작업

JobQueue -->> LocationJobProducer : 작업 큐잉 완료 (비동기)
LocationJobProducer --> SagaOrchestrator : 장소 검색 작업 시작됨

== 6. AI 일정 생성 (비동기 처리) ==

SagaOrchestrator -> AIEngine : generateItinerary(aiContext, async=true)
note right
  AI 생성 프로세스:
  1. 시간대별 활동 계획
  2. 멤버 특성별 강도 조절
  3. 이동 시간 고려 배치
  4. 식사/휴식 시간 삽입
  5. 최적 경로 계산
end note

AIEngine -> AIEngine : processTimeSlotAllocation()
AIEngine -> AIEngine : applyMemberCharacteristics() 
AIEngine -> AIEngine : optimizeRouteSequence()

== 7. 장소 정보 수신 및 통합 ==

JobQueue -->> SagaOrchestrator : 장소 검색 결과 수신 (비동기)
note right
  수신 데이터:
  - 관광지 목록 + 상세정보
  - 식당 목록 + 영업시간
  - 카페 목록 + 위치정보
  - 교통 소요시간 매트릭스
end note

SagaOrchestrator -> SagaOrchestrator : aggregateLocationData(searchResults)
SagaOrchestrator -> AIEngine : updateAIContextWithLocations(locationData)

AIEngine -> AIEngine : refineItineraryWithRealData()
AIEngine --> SagaOrchestrator : 최종 일정 생성 완료

== 8. CQRS 기반 데이터 저장 ==

SagaOrchestrator -> ItineraryWriteRepo : saveItinerary(itineraryCommand)
note right
  Command 모델:
  - 일정 생성 이벤트 기록
  - 변경 이력 추적
  - 비즈니스 규칙 검증
end note

ItineraryWriteRepo -> WriteDB : INSERT INTO itinerary_commands
ItineraryWriteRepo -> WriteDB : INSERT INTO itinerary_events
WriteDB --> ItineraryWriteRepo : 저장 완료

== 9. 읽기 모델 동기화 ==

ItineraryWriteRepo -->> ItineraryReadRepo : 이벤트 발행 (비동기)
note right
  이벤트 내용:
  - ItineraryCreated
  - PlacesAdded  
  - RoutesCalculated
end note

ItineraryReadRepo -> ReadDB : INSERT INTO itinerary_view
ItineraryReadRepo -> ReadDB : INSERT INTO place_view
ItineraryReadRepo -> ReadDB : INSERT INTO route_view
ReadDB --> ItineraryReadRepo : 읽기 모델 생성 완료

== 10. 캐시 저장 및 사가 완료 ==

SagaOrchestrator -> RedisCache : set("itinerary:" + itineraryId, data, ttl=1800)
RedisCache --> SagaOrchestrator : 캐시 저장 완료

SagaOrchestrator -> SagaOrchestrator : completeSagaTransaction(SUCCESS)
SagaOrchestrator --> ItineraryService : 일정 생성 완료

== 11. 응답 반환 ==

ItineraryService -> ItineraryReadRepo : findItineraryById(itineraryId)
ItineraryReadRepo -> ReadDB : SELECT FROM itinerary_view
ReadDB --> ItineraryReadRepo : 일정 조회 데이터
ItineraryReadRepo --> ItineraryService : 생성된 일정 정보

ItineraryService --> ItineraryController : 생성 완료 (201 Created)
ItineraryController --> Client : HTTP 201 Created + 일정 데이터

== 예외 처리: 사가 보상 트랜잭션 ==

alt 일정 생성 실패 시
    SagaOrchestrator -> SagaOrchestrator : executeCompensation()
    note right
      보상 작업:
      1. 생성된 임시 데이터 삭제
      2. 캐시 무효화
      3. 작업 큐 정리
      4. 실패 이벤트 기록
    end note
    
    SagaOrchestrator -> ItineraryWriteRepo : deleteIncompleteItinerary()
    SagaOrchestrator -> RedisCache : delete("itinerary:" + itineraryId)
    SagaOrchestrator -> JobQueue : cancelPendingJobs()
    
    SagaOrchestrator -> SagaOrchestrator : recordSagaFailure()
    SagaOrchestrator --> ItineraryService : 생성 실패
    ItineraryService --> ItineraryController : 에러 응답 (500 Internal Server Error)
end

@enduml
```

## 주요 처리 흐름 설명

### 1. 요청 검증 및 캐시 조회 단계
- **프로파일 캐시 우선**: 멤버 정보와 여행 기본 정보를 Redis 캐시에서 우선 조회
- **캐시 미스 시**: Profile Service API 호출하여 데이터 취득 후 캐시 저장
- **비즈니스 검증**: 날짜 유효성, 시간 설정 일관성 등 검증

### 2. AI 엔진 초기화
- **멤버 특성 분석**: 나이, 건강상태를 기반으로 일정 강도 계산
- **선호도 적용**: 멤버 선호사항을 기반으로 장소 카테고리 가중치 설정
- **자연어 처리**: 추가 요구사항을 분석하여 AI 컨텍스트에 반영

### 3. 사가 패턴 적용
- **분산 트랜잭션 관리**: 여러 외부 서비스 호출을 하나의 트랜잭션으로 관리
- **보상 트랜잭션**: 실패 시 이미 수행된 작업들을 되돌리는 보상 로직
- **상태 추적**: 각 단계별 상태를 추적하여 장애 복구 지원

### 4. 비동기 작업 큐 활용
- **장소 검색 병렬 처리**: 관광지, 식당, 카페 검색을 별도 작업으로 큐에 등록
- **논블로킹 처리**: 외부 Location Service 호출을 비동기로 처리하여 응답성 확보
- **결과 통합**: 각 검색 결과를 수신하여 AI 엔진에 실시간 반영

### 5. CQRS 패턴 적용  
- **Command 모델**: 일정 생성 명령을 이벤트 소싱 방식으로 기록
- **Query 모델**: 조회 최적화된 읽기 전용 뷰 생성
- **이벤트 기반 동기화**: Write DB와 Read DB 간 이벤트를 통한 비동기 동기화

### 6. 성능 최적화
- **Redis 캐시 활용**: 자주 조회되는 프로파일 정보와 생성된 일정 정보 캐싱
- **TTL 설정**: 데이터 특성에 맞는 적절한 캐시 만료 시간 설정
- **캐시 워밍**: 일정 생성 완료 즉시 캐시 저장으로 후속 조회 성능 확보

## 기술적 특징

### 비동기 처리 전략
- **Job Queue**: RabbitMQ 또는 Redis Queue를 활용한 작업 분산
- **이벤트 기반**: 도메인 이벤트를 통한 서비스 간 느슨한 결합
- **장애 격리**: Circuit Breaker 패턴으로 외부 서비스 장애 격리

### 데이터 일관성 보장
- **Event Sourcing**: 모든 변경 사항을 이벤트로 기록하여 완전한 감사 추적
- **Eventual Consistency**: 읽기 모델은 최종 일관성으로 동기화
- **보상 트랜잭션**: 분산 환경에서 데이터 일관성 보장

### 확장성 고려사항
- **수평 확장**: 각 컴포넌트별 독립적 스케일링 가능
- **부하 분산**: 작업 큐를 통한 부하 분산
- **캐시 계층**: 다단계 캐시로 외부 API 호출 최소화