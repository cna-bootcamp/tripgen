# 일정 서비스 - AI 기반 일정 생성 내부 시퀀스

## 시나리오 개요
- **시나리오명**: ai-itinerary-generation  
- **주요 API**: 
  - POST /api/itinerary/trips/{tripId}/itineraries (generateItinerary) - 비동기 처리 (202 Accepted)
  - GET /api/itinerary/trips/{tripId}/generation-status/{jobId} (getGenerationStatus)
- **유저스토리**: RQ-ITIN-001 - 멤버 특성을 고려한 시간대별 상세 일정을 자동으로 생성
- **처리 방식**: Claude API 기반 AI 일정 생성 및 장소 검증 (비동기)

## PlantUML 시퀀스 다이어그램

```plantuml
@startuml
!theme mono

title 일정 서비스 - AI 기반 일정 생성 내부 시퀀스 (비동기)

actor Client as "클라이언트"
participant ItineraryController as "일정\n컨트롤러"
participant ItineraryService as "일정\n서비스"
participant ProfileCacheService as "프로파일\n캐시서비스"
participant AIOrchestrator as "AI\n오케스트레이터"
participant PromptBuilder as "프롬프트\n빌더"
participant ClaudeAPIClient as "Claude API\n클라이언트"
participant ResponseParser as "응답\n파서"
participant LocationValidator as "장소\n검증기"
participant ItineraryWriteRepo as "일정쓰기\n저장소"
participant ItineraryReadRepo as "일정읽기\n저장소"
participant RedisCache as "Redis\n캐시"
database WriteDB as "쓰기\nDB"
database ReadDB as "읽기\nDB"

== 1. 일정 생성 요청 수신 ==

Client -> ItineraryController : POST /api/itinerary/trips/{tripId}/itineraries
note right
  요청 데이터:
  - date: 생성할 날짜
  - additionalRequirements: 추가 요구사항
  - preferences: 일정 생성 선호 옵션
  - maxRetries: 최대 재시도 횟수
  - timeoutSeconds: 타임아웃 설정
end note

ItineraryController -> ItineraryService : generateItinerary(tripId, request)

== 2. 요청 검증 및 비동기 작업 생성 ==

ItineraryService -> ItineraryService : validateRequest(request)
note right
  비즈니스 검증:
  - 날짜 유효성 (미래 날짜)
  - 시간 설정 일관성
  - 여행 기간 내 날짜인지 확인
end note

ItineraryService -> ItineraryService : generateJobId()
note right
  작업 ID 생성:
  - UUID v4 형식
  - 상태 조회에 사용
end note

ItineraryService -> WriteDB : INSERT INTO generation_jobs (jobId, status='PENDING')
WriteDB --> ItineraryService : 저장 완료

ItineraryService -> RedisCache : set("job:" + jobId, {status: 'PENDING'}, ttl=3600)
RedisCache --> ItineraryService : 캐시 저장 완료

ItineraryService --> ItineraryController : 작업 접수 완료 (202 Accepted)
ItineraryController --> Client : HTTP 202 Accepted
note right
  응답 내용:
  - jobId: 작업 ID
  - status: "PENDING"
  - message: "일정 생성 요청이 접수되었습니다"
end note

== 3. 비동기 처리 시작 ==

ItineraryService -->> AIOrchestrator : [비동기] generateItinerary(jobId, tripId, request)
note over AIOrchestrator
  백그라운드에서 비동기 처리 시작
  클라이언트는 이미 202 응답을 받음
end note

AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='PROCESSING', startedAt=NOW()
AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'PROCESSING', progress: 10}, ttl=3600)

== 4. 프로파일 캐시 조회 ==

AIOrchestrator -> ProfileCacheService : getMemberProfiles(tripId)
ProfileCacheService -> RedisCache : get("profile:member:" + tripId)

alt 캐시 히트
    RedisCache --> ProfileCacheService : 멤버 프로파일 데이터
else 캐시 미스
    ProfileCacheService -> ProfileCacheService : [외부 호출] Profile Service API
    ProfileCacheService -> RedisCache : set("profile:member:" + tripId, data, ttl=3600)
    RedisCache --> ProfileCacheService : 저장 완료
end

ProfileCacheService --> AIOrchestrator : 멤버 특성 정보

AIOrchestrator -> ProfileCacheService : getTripBasicInfo(tripId)
ProfileCacheService -> RedisCache : get("profile:trip:" + tripId)

alt 캐시 히트
    RedisCache --> ProfileCacheService : 여행 기본정보 데이터
else 캐시 미스
    ProfileCacheService -> ProfileCacheService : [외부 호출] Profile Service API  
    ProfileCacheService -> RedisCache : set("profile:trip:" + tripId, data, ttl=3600)
end

ProfileCacheService --> AIOrchestrator : 여행 기본정보

== 5. Claude 프롬프트 생성 및 AI 일정 생성 ==

AIOrchestrator -> PromptBuilder : buildItineraryPrompt(memberProfiles, tripInfo, requirements)
note right
  프롬프트 구성:
  - 멤버 특성 (나이, 건강상태, 선호도)
  - 여행 정보 (일정, 목적지, 예산)
  - 추가 요구사항 (자연어)
  - 출력 형식 지정 (JSON)
end note

PromptBuilder --> AIOrchestrator : 구조화된 프롬프트

AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'PROCESSING', progress: 20}, ttl=3600)

loop Claude API 호출 및 장소 검증 (최대 3회)
    AIOrchestrator -> ClaudeAPIClient : callClaudeAPI(prompt, retryCount)
    note right
      Claude API 설정:
      - 모델: Claude-3-Opus
      - Temperature: 0.7
      - Max tokens: 4000
      - System prompt 포함
    end note
    
    AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'PROCESSING', progress: 45, message: 'Claude API 호출 중...'}, ttl=3600)
    
    alt Claude API 성공
        ClaudeAPIClient --> AIOrchestrator : Claude 텍스트 응답
        
        AIOrchestrator -> ResponseParser : parseItineraryResponse(claudeResponse)
        note right
          파싱 내용:
          - 시간대별 일정 추출
          - 장소명/주소 정보
          - 이동 경로 정보
          - 예상 소요시간
        end note
        
        ResponseParser --> AIOrchestrator : 구조화된 일정 데이터
        
        == 6. 장소 검증 프로세스 ==
        
        AIOrchestrator -> LocationValidator : validateAllPlaces(itineraryPlaces)
        note right
          일괄 검증:
          - Claude 추천 장소들
          - Location Service API 호출
          - 실제 존재 여부 확인
          - 영업시간/위치 정보 확인
        end note
        
        LocationValidator -> LocationValidator : [외부 호출] POST /places/validate-batch
        LocationValidator --> AIOrchestrator : 검증 결과 (성공/실패 목록)
        
        AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'PROCESSING', progress: 70}, ttl=3600)
        
        alt 모든 장소 검증 성공
            AIOrchestrator -> AIOrchestrator : 일정 생성 성공
            break
        else 일부 장소 검증 실패
            AIOrchestrator -> PromptBuilder : buildRetryPrompt(failedPlaces, previousResponse)
            note right
              재시도 프롬프트:
              - 실패한 장소 목록
              - 대체 장소 요청
              - 이전 응답 참조
            end note
            
            AIOrchestrator -> AIOrchestrator : applyExponentialBackoff(retryCount)
            note right
              Exponential Backoff:
              - 1회: 1초 대기
              - 2회: 2초 대기
              - 3회: 4초 대기
            end note
        end
        
    else Claude API 실패
        ClaudeAPIClient --> AIOrchestrator : CLAUDE_API_ERROR
        AIOrchestrator -> WriteDB : INSERT INTO claude_generation_logs (error)
        AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='FAILED', failedAt=NOW()
        AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'FAILED', error: 'CLAUDE_API_ERROR'}, ttl=3600)
    end
end

alt 최대 재시도 초과
    AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='FAILED', error='MAX_RETRY_EXCEEDED'
    AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'FAILED', error: 'MAX_RETRY_EXCEEDED'}, ttl=3600)
    AIOrchestrator -> AIOrchestrator : 비동기 처리 종료
end

== 7. CQRS 기반 데이터 저장 ==

AIOrchestrator -> ItineraryWriteRepo : saveItinerary(itineraryCommand)
note right
  Command 모델:
  - 일정 생성 이벤트 기록
  - Claude 생성 로그 저장
  - 검증 상태 기록
  - 변경 이력 추적
end note

ItineraryWriteRepo -> WriteDB : INSERT INTO itinerary_commands
ItineraryWriteRepo -> WriteDB : INSERT INTO itinerary_events
ItineraryWriteRepo -> WriteDB : INSERT INTO claude_generation_logs
note right
  로그 내용:
  - 프롬프트 전문
  - Claude 응답 전문
  - 재시도 횟수
  - 검증 결과
end note
WriteDB --> ItineraryWriteRepo : 저장 완료

AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'PROCESSING', progress: 85}, ttl=3600)

== 8. 읽기 모델 동기화 ==

ItineraryWriteRepo -->> ItineraryReadRepo : 이벤트 발행 (비동기)
note right
  이벤트 내용:
  - ItineraryCreated
  - PlacesValidated
  - RoutesCalculated
end note

ItineraryReadRepo -> ReadDB : INSERT INTO itinerary_view
ItineraryReadRepo -> ReadDB : INSERT INTO place_view
ItineraryReadRepo -> ReadDB : INSERT INTO route_view
ReadDB --> ItineraryReadRepo : 읽기 모델 생성 완료

== 9. 작업 완료 처리 ==

AIOrchestrator -> RedisCache : set("itinerary:" + itineraryId, data, ttl=1800)
RedisCache --> AIOrchestrator : 캐시 저장 완료

AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='COMPLETED', completedAt=NOW(), result={itineraryId, date, dayNumber}
AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'COMPLETED', progress: 100, result: {itineraryId, date, dayNumber}}, ttl=3600)

== 10. 클라이언트의 상태 조회 ==

Client -> ItineraryController : GET /api/itinerary/trips/{tripId}/generation-status/{jobId}
ItineraryController -> ItineraryService : getGenerationStatus(tripId, jobId)

ItineraryService -> RedisCache : get("job:" + jobId)
alt 캐시 히트
    RedisCache --> ItineraryService : 작업 상태 데이터
else 캐시 미스
    ItineraryService -> ReadDB : SELECT FROM generation_jobs WHERE jobId = ?
    ReadDB --> ItineraryService : 작업 상태 데이터
end

ItineraryService --> ItineraryController : 작업 상태 (200 OK)
ItineraryController --> Client : HTTP 200 OK + GenerationStatus
note right
  상태별 응답:
  - PENDING: progress=0
  - PROCESSING: progress=1-99
  - COMPLETED: progress=100 + result
  - FAILED: error 정보 포함
end note

== 예외 처리: 비동기 에러 핸들링 ==

alt CLAUDE_API_ERROR (비동기 처리 중)
    ClaudeAPIClient --> AIOrchestrator : API 호출 실패
    AIOrchestrator -> WriteDB : INSERT INTO error_logs (type='CLAUDE_API_ERROR')
    AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='FAILED', error='Claude API 오류'
    AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'FAILED', error: 'Claude API 오류'}, ttl=3600)
end

alt PLACE_VALIDATION_FAILED (모든 재시도 실패)
    LocationValidator --> AIOrchestrator : 장소 검증 실패
    AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='FAILED', error='장소 검증 실패'
    AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'FAILED', error: '추천 장소 검증 실패'}, ttl=3600)
end

alt TIMEOUT_ERROR
    AIOrchestrator -> AIOrchestrator : 타임아웃 감지 (30초 초과)
    AIOrchestrator -> WriteDB : UPDATE generation_jobs SET status='FAILED', error='TIMEOUT'
    AIOrchestrator -> RedisCache : set("job:" + jobId, {status: 'FAILED', error: 'Claude API response timeout after 30 seconds'}, ttl=3600)
end

@enduml
```

## 주요 처리 흐름 설명

### 1. 비동기 처리 아키텍처
- **즉시 응답**: 클라이언트는 작업 ID를 받고 즉시 202 Accepted 응답을 받음
- **백그라운드 처리**: AI 일정 생성은 백그라운드에서 비동기로 진행
- **상태 조회**: 클라이언트는 작업 ID로 진행 상태를 조회 가능
- **진행률 추적**: 각 단계별로 progress를 업데이트하여 세밀한 진행 상황 제공

### 2. 작업 상태 관리
- **PENDING**: 작업이 대기열에 있음 (progress: 0)
- **PROCESSING**: 작업이 진행 중 (progress: 1-99)
- **COMPLETED**: 작업이 성공적으로 완료됨 (progress: 100)
- **FAILED**: 작업이 실패함 (에러 정보 포함)

### 3. Claude API 기반 AI 일정 생성
- **AI 오케스트레이터**: 전체 AI 일정 생성 플로우를 관리하는 중앙 컴포넌트
- **프롬프트 빌더**: 멤버 프로파일과 여행 정보를 Claude가 이해할 수 있는 구조화된 프롬프트로 변환
- **Claude API 클라이언트**: Claude-3-Opus 모델을 활용한 AI 일정 생성
- **응답 파서**: Claude의 텍스트 응답을 구조화된 JSON 형식으로 파싱

### 4. 장소 검증 및 재시도 메커니즘
- **일괄 검증**: POST /places/validate-batch API를 통해 Claude 추천 장소를 한 번에 검증
- **검증 내용**: 실제 존재 여부, 영업시간, 정확한 위치 정보 확인
- **재시도 전략**: 검증 실패 시 최대 3회까지 Claude에게 대체 장소 요청
- **Exponential Backoff**: 재시도 간격을 점진적으로 증가 (1초 → 2초 → 4초)

### 5. 데이터 저장 및 로깅
- **Generation Jobs 테이블**: 작업 상태 및 진행 상황 추적
- **Claude 생성 로그**: 모든 프롬프트와 응답을 claude_generation_logs 테이블에 저장
- **검증 상태 추적**: 장소 검증 진행 상황 기록
- **에러 로깅**: 각 단계별 에러를 상세히 기록하여 디버깅 지원

### 6. CQRS 패턴 적용  
- **Command 모델**: 일정 생성 명령과 Claude 로그를 이벤트 소싱 방식으로 기록
- **Query 모델**: 조회 최적화된 읽기 전용 뷰 생성
- **이벤트 기반 동기화**: Write DB와 Read DB 간 이벤트를 통한 비동기 동기화

### 7. 에러 처리 전략
- **CLAUDE_API_ERROR**: Claude API 호출 실패 시 작업 상태를 FAILED로 변경
- **PLACE_VALIDATION_FAILED**: 모든 재시도 후에도 장소 검증 실패 시 FAILED
- **TIMEOUT_ERROR**: 설정된 타임아웃(기본 30초) 초과 시 FAILED
- **MAX_RETRY_EXCEEDED**: 최대 재시도 횟수 초과 시 FAILED

## 기술적 특징

### 비동기 처리의 장점
- **높은 응답성**: 클라이언트는 즉시 응답을 받고 다른 작업 수행 가능
- **타임아웃 방지**: 긴 처리 시간에도 HTTP 타임아웃 발생하지 않음
- **에러 격리**: 백그라운드 처리 중 발생한 에러가 클라이언트에 직접 영향 없음
- **재시도 가능**: 실패한 작업을 재시도하거나 재실행 가능

### Claude API 통합
- **모델 선택**: Claude-3-Opus를 활용한 고품질 일정 생성
- **프롬프트 엔지니어링**: 구조화된 프롬프트로 일관된 응답 형식 유도
- **응답 파싱**: 자연어 응답을 구조화된 JSON으로 변환하는 강력한 파서
- **재시도 메커니즘**: 검증 실패 시 컨텍스트를 유지하며 대체 장소 요청

### 데이터 일관성 보장
- **Event Sourcing**: 모든 Claude 상호작용과 변경 사항을 이벤트로 기록
- **Eventual Consistency**: 읽기 모델은 최종 일관성으로 동기화
- **작업 상태 관리**: generation_jobs 테이블을 통한 작업 추적

### 성능 및 안정성
- **캐시 활용**: Redis를 통한 프로파일 정보 캐싱으로 API 호출 최소화
- **진행률 추적**: Redis에 실시간 진행 상황 저장으로 빠른 상태 조회
- **Exponential Backoff**: 재시도 시 점진적 대기 시간 증가로 시스템 부하 분산
- **타임아웃 관리**: 각 작업별 타임아웃 설정으로 무한 대기 방지

### 모니터링 및 디버깅
- **상세 로깅**: 모든 Claude 프롬프트와 응답을 데이터베이스에 저장
- **진행률 모니터링**: 각 단계별 진행률로 병목 구간 파악 가능
- **에러 추적**: 각 에러 타입별 로그 기록으로 문제 진단 용이
- **검증 이력**: 장소 검증 성공/실패 이력 추적으로 Claude 성능 분석 가능