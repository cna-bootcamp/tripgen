@startuml
!theme mono
title 일정 서비스 - 장소 상세정보 제공 내부 시퀀스

!define CONTROLLER_COLOR #E3F2FD
!define SERVICE_COLOR #E8F5E8
!define REPOSITORY_COLOR #FFF3E0
!define CACHE_COLOR #FFEBEE
!define EXTERNAL_COLOR #F3E5F5

participant "PlaceController" as PC <<Controller>> CONTROLLER_COLOR
participant "PlaceService" as PS <<Service>> SERVICE_COLOR
participant "PlaceRepository" as PR <<Repository>> REPOSITORY_COLOR
participant "Redis Cache" as RC <<Cache>> CACHE_COLOR
participant "API Gateway" as AG <<External>> EXTERNAL_COLOR
participant "Location Service" as LS <<External>> EXTERNAL_COLOR

== 1. 일정 내 장소 목록 조회 ==

PC -> PC: GET /api/itinerary/trips/{tripId}/itineraries/{itineraryId}/places
note right: 일정에 포함된 장소 목록 조회 요청

PC -> PS: getPlacesInItinerary(tripId, itineraryId)
activate PS

PS -> RC: getCachedPlaceList(tripId + itineraryId)
activate RC
RC --> PS: 캐시된 장소 목록 (있는 경우)
deactivate RC

alt 캐시에서 데이터 발견
    PS --> PC: List<Place> 반환
else 캐시에 데이터 없음
    PS -> PR: findPlacesByItineraryId(itineraryId)
    activate PR
    PR --> PS: List<Place> 반환
    deactivate PR
    
    PS -> RC: cachePlaceList(tripId + itineraryId, places, TTL:1800)
    note right: 30분 TTL로 캐시 저장
    
    PS --> PC: List<Place> 반환
end

deactivate PS
PC --> PC: HTTP 200 응답

== 2. 일정에 장소 추가 ==

PC -> PC: POST /api/itinerary/trips/{tripId}/itineraries/{itineraryId}/places
note right: 새로운 장소를 일정에 추가 요청

PC -> PS: addPlaceToItinerary(tripId, itineraryId, placeRequest)
activate PS

' 비즈니스 로직 검증
PS -> PS: validateTimeSlot(placeRequest.startTime, placeRequest.endTime)
note right: 시간대 중복 검사 및 유효성 검증

PS -> PS: validatePlaceCategory(placeRequest.category)
note right: 카테고리별 추천 시간대 검증

alt 시간대 중복 발생
    PS --> PC: throw TimeSlotConflictException
    PC --> PC: HTTP 400 응답
else 검증 통과
    PS -> PR: savePlace(place)
    activate PR
    PR --> PS: Place 저장된 엔티티
    deactivate PR
    
    PS -> PS: generateMapSearchKeyword(place)
    note right: 지도 검색용 키워드 생성
    
    PS -> RC: invalidatePlaceListCache(tripId + itineraryId)
    note right: 장소 목록 캐시 무효화
    
    PS --> PC: Place 반환
    PC --> PC: HTTP 201 응답
end

deactivate PS

== 3. 장소 상세 정보 조회 (MCP 연동) ==

PC -> PC: GET /api/itinerary/places/{placeId}?refresh=true
note right: 실시간 갱신 옵션으로 장소 상세 정보 조회

PC -> PS: getPlaceDetail(placeId, refresh)
activate PS

' Cache-aside 패턴 적용
PS -> RC: getCachedPlaceDetail(placeId)
activate RC
RC --> PS: 캐시된 PlaceDetail (있는 경우)
deactivate RC

alt 캐시 히트 && !refresh
    PS --> PC: PlaceDetail 반환
    
else 캐시 미스 || refresh=true
    PS -> PR: findPlaceById(placeId)
    activate PR
    PR --> PS: Place 기본 정보
    deactivate PR
    
    ' Location Service 통해 실시간 정보 조회
    PS -> AG: GET /places/{placeId}?include_reviews=true&include_photos=true
    note right: Circuit Breaker 적용된 외부 API 호출
    
    activate AG
    AG -> LS: 실시간 장소 정보 요청
    activate LS
    
    alt Location Service 정상 응답
        LS --> AG: PlaceExternalInfo (영업시간, 평점, 연락처 등)
        AG --> PS: PlaceExternalInfo
        
        ' MCP 데이터를 통합하여 PlaceDetail 구성
        PS -> PS: mergePlaceDetails(place, externalInfo)
        note right: - 실시간 영업시간 업데이트\n- 평점 정보 갱신\n- 주차장 정보 검증\n- 혼잡도 정보 추가
        
        PS -> RC: cachePlaceDetail(placeId, placeDetail, TTL:600)
        note right: 10분 TTL로 실시간 정보 캐시
        
    else Location Service 장애 (Circuit Breaker 동작)
        AG --> PS: ServiceUnavailableException
        PS -> PS: useFallbackPlaceDetail(place)
        note right: 캐시된 기본 정보만으로 응답 구성
        
    end
    
    deactivate LS
    deactivate AG
    
    PS --> PC: PlaceDetail 반환
end

deactivate PS
PC --> PC: HTTP 200 응답

== 4. 장소 정보 수정 ==

PC -> PC: PUT /api/itinerary/places/{placeId}
note right: 장소 정보 수정 요청 (추천이유, 방문시간 등)

PC -> PS: updatePlace(placeId, updateRequest)
activate PS

PS -> PR: findPlaceById(placeId)
activate PR
PR --> PS: 기존 Place 정보
deactivate PR

alt 장소 존재하지 않음
    PS --> PC: throw PlaceNotFoundException
    PC --> PC: HTTP 404 응답
    
else 장소 존재
    PS -> PS: validateUpdateRequest(updateRequest)
    note right: - 시간대 중복 재검사\n- 순서(order) 유효성 검증
    
    alt 검증 실패
        PS --> PC: throw ValidationException
        PC --> PC: HTTP 400 응답
        
    else 검증 성공
        PS -> PS: updatePlaceFields(place, updateRequest)
        
        PS -> PR: updatePlace(place)
        activate PR
        PR --> PS: 업데이트된 Place
        deactivate PR
        
        ' 관련 캐시 무효화
        PS -> RC: invalidatePlaceDetailCache(placeId)
        PS -> RC: invalidatePlaceListCache(place.tripId + place.itineraryId)
        
        PS --> PC: 업데이트된 Place 반환
        PC --> PC: HTTP 200 응답
    end
end

deactivate PS

== 5. 장소 삭제 ==

PC -> PC: DELETE /api/itinerary/places/{placeId}
note right: 일정에서 장소 삭제 요청

PC -> PS: deletePlace(placeId)
activate PS

PS -> PR: findPlaceById(placeId)
activate PR
PR --> PS: Place 정보 (삭제 전 조회)
deactivate PR

alt 장소 존재하지 않음
    PS --> PC: throw PlaceNotFoundException
    PC --> PC: HTTP 404 응답
    
else 장소 존재
    PS -> PR: deletePlace(placeId)
    activate PR
    PR --> PS: 삭제 완료
    deactivate PR
    
    ' 순서 재정렬
    PS -> PS: reorderRemainingPlaces(place.itineraryId, place.order)
    note right: 삭제된 장소 이후 순서 자동 조정
    
    ' 관련 캐시 정리
    PS -> RC: invalidatePlaceDetailCache(placeId)
    PS -> RC: invalidatePlaceListCache(place.tripId + place.itineraryId)
    
    PS --> PC: 삭제 완료
    PC --> PC: HTTP 204 응답
end

deactivate PS

== 캐시 관리 전략 ==

note over RC: **Cache-aside 패턴 적용**\n- 장소 목록: TTL 30분\n- 장소 상세: TTL 10분 (실시간 정보 포함)\n- 수정/삭제 시 관련 캐시 즉시 무효화

note over AG: **Circuit Breaker 패턴**\n- Location Service 장애 시 Fallback\n- 실패율 50% 이상 시 Circuit Open\n- Half-Open 상태에서 점진적 복구

note over PS: **비즈니스 로직**\n- 시간대 중복 방지 검증\n- 카테고리별 권장 체류시간 적용\n- 방문 순서 자동 관리\n- 지도 검색 키워드 자동 생성

@enduml