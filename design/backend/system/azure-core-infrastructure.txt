# Azure Cloud 기반 여행 일정 생성 서비스 - 핵심 인프라 아키텍처

## 🎯 설계 개요

### 목표
- 마이크로서비스 아키텍처 기반 Azure 네이티브 클라우드 인프라 구성
- 컨테이너 기반 서비스 배포와 서버리스 컴퓨팅 하이브리드 활용
- 고가용성, 확장성, 성능 최적화를 동시에 만족하는 인프라 설계

### 설계 원칙
1. **클라우드 네이티브**: Azure 관리형 서비스 우선 활용
2. **마이크로서비스**: 서비스별 독립적 배포 및 확장
3. **데이터 독립성**: 서비스별 전용 데이터 저장소
4. **API First**: API Gateway 중심의 통신 구조
5. **캐시 우선**: Redis를 통한 성능 최적화
6. **비용 최적화**: 사용량 기반 스케일링

---

## 🏗️ 전체 아키텍처 개요

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Azure Cloud Platform                           │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐    ┌──────────────────────────────────────────┐ │
│  │   Azure Front   │    │            Azure API Management          │ │
│  │     Door        │ -> │         (API Gateway Pattern)            │ │
│  │    (Global)     │    │                                          │ │
│  └─────────────────┘    └──────────────────────────────────────────┘ │
│                                           │                         │
│  ┌─────────────────────────────────────────┼─────────────────────────┐ │
│  │              Azure Container Apps Environment                    │ │
│  │                                         │                       │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌────────────┐ │ │
│  │  │  Profile    │ │ Itinerary   │ │  Location   │ │   MCP      │ │ │
│  │  │  Service    │ │  Service    │ │  Service    │ │  Proxy     │ │ │
│  │  │ (Container) │ │ (Container) │ │ (Container) │ │(Function)  │ │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                           │                         │
│  ┌─────────────────────────────────────────┼─────────────────────────┐ │
│  │                 Data Tier               │                       │ │
│  │  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐ │ │
│  │  │   Profile DB    │ │  Itinerary DB   │ │   Location DB       │ │ │
│  │  │  (PostgreSQL)   │ │  (PostgreSQL)   │ │  (PostgreSQL)       │ │ │
│  │  └─────────────────┘ └─────────────────┘ └─────────────────────┘ │ │
│  │                                                                 │ │
│  │  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐ │ │
│  │  │  Redis Cache    │ │  Service Bus    │ │   Blob Storage      │ │ │
│  │  │   (Premium)     │ │   (Premium)     │ │    (Standard)       │ │ │
│  │  └─────────────────┘ └─────────────────┘ └─────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 🏢 마이크로서비스별 Azure 서비스 매핑

### 1. 프로파일 서비스 (Profile Service)

| 컴포넌트 | Azure 서비스 | SKU/계층 | 용도 |
|---------|-------------|----------|-----|
| 애플리케이션 | Azure Container Apps | 0.25 vCPU, 0.5Gi RAM | Spring Boot 애플리케이션 |
| 데이터베이스 | Azure Database for PostgreSQL | GP 2 vCore, 32GB Storage | 프로파일/여행 데이터 저장 |
| 캐시 | Azure Cache for Redis | Standard C1 (1GB) | 세션/프로파일 캐시 |
| 메시징 | Azure Service Bus | Standard | 프로파일 변경 이벤트 |

**배포 구성**:
```yaml
# profile-service-container-app.yaml
properties:
  environmentId: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.App/managedEnvironments/tripgen-env
  configuration:
    ingress:
      external: false
      targetPort: 8080
    secrets:
      - name: db-connection-string
        value: postgresql://profile-db.postgres.database.azure.com:5432/profiledb
  template:
    containers:
      - image: tripgen.azurecr.io/profile-service:latest
        name: profile-service
        resources:
          cpu: 0.25
          memory: 0.5Gi
        env:
          - name: SPRING_DATASOURCE_URL
            secretRef: db-connection-string
          - name: REDIS_HOST
            value: tripgen-cache.redis.cache.windows.net
    scale:
      minReplicas: 1
      maxReplicas: 10
      rules:
        - name: http-rule
          http:
            metadata:
              concurrentRequests: '10'
```

### 2. 일정 서비스 (Itinerary Service)

| 컴포넌트 | Azure 서비스 | SKU/계층 | 용도 |
|---------|-------------|----------|-----|
| 애플리케이션 | Azure Container Apps | 0.5 vCPU, 1Gi RAM | Spring Boot 애플리케이션 |
| 데이터베이스 | Azure Database for PostgreSQL | GP 4 vCore, 64GB Storage | 일정/활동 데이터 저장 |
| Job Queue | Azure Service Bus | Premium | AI 일정 생성 작업 큐 |
| 파일 저장소 | Azure Blob Storage | Hot Tier | 사진/첨부파일 저장 |

**배포 구성**:
```yaml
# itinerary-service-container-app.yaml
properties:
  template:
    containers:
      - image: tripgen.azurecr.io/itinerary-service:latest
        name: itinerary-service
        resources:
          cpu: 0.5
          memory: 1Gi
    scale:
      minReplicas: 2
      maxReplicas: 20
      rules:
        - name: service-bus-rule
          azureQueue:
            queueName: ai-itinerary-queue
            queueLength: '5'
```

### 3. 장소 서비스 (Location Service)

| 컴포넌트 | Azure 서비스 | SKU/계층 | 용도 |
|---------|-------------|----------|-----|
| 애플리케이션 | Azure Container Apps | 0.25 vCPU, 0.5Gi RAM | Spring Boot 애플리케이션 |
| 데이터베이스 | Azure Database for PostgreSQL | GP 2 vCore, 32GB Storage + PostGIS | 장소 데이터 및 공간 정보 |
| 캐시 | Azure Cache for Redis | Premium P1 (6GB) | 장소 정보 및 검색 결과 캐시 |
| 번역 서비스 | Azure Translator | S1 Standard | 다국어 장소명 번역 |

### 4. MCP 프록시 (외부 API 통합)

| 컴포넌트 | Azure 서비스 | SKU/계층 | 용도 |
|---------|-------------|----------|-----|
| 프록시 함수 | Azure Functions | Premium EP1 | 카카오/구글 MCP API 프록시 |
| API 관리 | Azure API Management | Developer | 외부 API 통합 및 관리 |
| 키 저장소 | Azure Key Vault | Standard | API 키 및 비밀 관리 |

**함수 배포 구성**:
```javascript
// mcp-proxy-function/index.js
module.exports = async function (context, req) {
    const { provider, endpoint, params } = req.body;
    
    try {
        let apiKey, baseUrl;
        
        if (provider === 'kakao') {
            apiKey = process.env.KAKAO_API_KEY;
            baseUrl = 'https://dapi.kakao.com';
        } else if (provider === 'google') {
            apiKey = process.env.GOOGLE_API_KEY;
            baseUrl = 'https://maps.googleapis.com';
        }
        
        const response = await fetch(`${baseUrl}${endpoint}?key=${apiKey}&${new URLSearchParams(params)}`);
        const data = await response.json();
        
        context.res = {
            status: 200,
            body: data
        };
    } catch (error) {
        context.log.error('MCP Proxy Error:', error);
        context.res = {
            status: 500,
            body: { error: 'External API call failed' }
        };
    }
};
```

---

## 🌐 API 게이트웨이 설계

### Azure API Management 구성

#### 1. 정책 설정
```xml
<!-- API Gateway 정책 -->
<policies>
    <inbound>
        <!-- CORS 정책 -->
        <cors allow-credentials="true">
            <allowed-origins>
                <origin>https://tripgen.com</origin>
                <origin>https://app.tripgen.com</origin>
            </allowed-origins>
            <allowed-methods>
                <method>GET</method>
                <method>POST</method>
                <method>PUT</method>
                <method>DELETE</method>
            </allowed-methods>
        </cors>
        
        <!-- 인증 정책 -->
        <validate-jwt header-name="Authorization" failed-validation-httpcode="401">
            <openid-config url="https://login.microsoftonline.com/{tenant}/v2.0/.well-known/openid_configuration" />
        </validate-jwt>
        
        <!-- 속도 제한 -->
        <rate-limit calls="1000" renewal-period="60" />
        
        <!-- 로깅 -->
        <log-to-eventhub logger-id="tripgen-logger">
            <message>@{
                return new JObject(
                    new JProperty("RequestId", context.RequestId),
                    new JProperty("Method", context.Request.Method),
                    new JProperty("Url", context.Request.Url.Path),
                    new JProperty("UserAgent", context.Request.Headers.GetValueOrDefault("User-Agent")),
                    new JProperty("ClientIP", context.Request.IpAddress)
                ).ToString();
            }</message>
        </log-to-eventhub>
    </inbound>
    
    <backend>
        <!-- 서킷 브레이커 -->
        <retry condition="@(context.Response.StatusCode >= 500)" count="3" interval="2">
            <forward-request />
        </retry>
    </backend>
    
    <outbound>
        <!-- 캐시 헤더 -->
        <cache-store-value key="@("cache-" + context.RequestId)" value="@(context.Response.Body)" duration="300" />
    </outbound>
</policies>
```

#### 2. API 라우팅 구성
```yaml
# api-routing-config.yaml
apis:
  - name: profile-api
    path: /api/profile
    backend: https://profile-service.internal.domain.com
    policies:
      - cache: 300s  # 5분 캐시
      - throttle: 100req/min
      
  - name: itinerary-api
    path: /api/itinerary
    backend: https://itinerary-service.internal.domain.com
    policies:
      - cache: 60s   # 1분 캐시
      - throttle: 200req/min
      
  - name: location-api
    path: /api/location
    backend: https://location-service.internal.domain.com
    policies:
      - cache: 600s  # 10분 캐시
      - throttle: 500req/min
      
  - name: mcp-proxy-api
    path: /api/external
    backend: https://tripgen-mcp-proxy.azurewebsites.net
    policies:
      - cache: 1800s # 30분 캐시
      - throttle: 50req/min
```

---

## 🏢 컨테이너 및 서버리스 전략

### 1. 컨테이너 배포 전략

#### Container Apps Environment 설정
```yaml
# container-apps-environment.yaml
location: Korea Central
properties:
  appLogsConfiguration:
    destination: log-analytics
    logAnalyticsConfiguration:
      customerId: {workspace-customer-id}
      sharedKey: {workspace-shared-key}
  
  vnetConfiguration:
    infrastructureSubnetId: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.Network/virtualNetworks/tripgen-vnet/subnets/container-subnet
    
  workloadProfiles:
    - name: Consumption
      workloadProfileType: Consumption
    - name: Dedicated-D4
      workloadProfileType: D4
      minimumCount: 1
      maximumCount: 5
```

#### 이미지 레지스트리 전략
```bash
# Azure Container Registry 설정
az acr create \
  --resource-group tripgen-rg \
  --name tripgenregistry \
  --sku Premium \
  --location "Korea Central"

# 이미지 빌드 및 푸시 자동화
az acr task create \
  --registry tripgenregistry \
  --name build-profile-service \
  --image profile-service:{{.Run.ID}} \
  --context https://github.com/tripgen/profile-service.git \
  --file Dockerfile \
  --commit-trigger-enabled true
```

### 2. 서버리스 전략 (Azure Functions)

#### MCP Proxy Functions 구성
```json
{
  "version": "2.0",
  "functionApp": {
    "httpWorker": {
      "description": {
        "defaultExecutablePath": "node",
        "defaultWorkerPath": "dist/src/index.js"
      }
    }
  },
  "functions": [
    {
      "name": "kakao-mcp-proxy",
      "entryPoint": "handlers.kakaoProxy",
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": ["post"]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    {
      "name": "google-mcp-proxy",
      "entryPoint": "handlers.googleProxy",
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": ["post"]
        }
      ]
    }
  ]
}
```

---

## 🗄️ 데이터 저장소 아키텍처

### 1. PostgreSQL 구성 (서비스별)

#### Profile Service Database
```yaml
# profile-postgresql.yaml
location: Korea Central
sku:
  name: GP_Gen5_2
  tier: GeneralPurpose
  family: Gen5
  capacity: 2
properties:
  administratorLogin: profileadmin
  version: '13'
  storageProfile:
    storageMB: 32768
    backupRetentionDays: 7
    geoRedundantBackup: Enabled
  
  # 고가용성 구성
  availabilityZone: '1'
  standbyAvailabilityZone: '2'
  
  # 보안 설정
  sslEnforcement: Enabled
  minimalTlsVersion: TLS1_2
  
  # 네트워크 설정
  publicNetworkAccess: Disabled
  
  configurations:
    - name: shared_preload_libraries
      value: pg_stat_statements
    - name: log_statement
      value: all
    - name: max_connections
      value: '100'
```

#### Itinerary Service Database (확장형)
```yaml
# itinerary-postgresql.yaml
sku:
  name: GP_Gen5_4  # 더 높은 성능
  capacity: 4
properties:
  storageProfile:
    storageMB: 65536  # 64GB
    
  # 파티셔닝 지원을 위한 설정
  configurations:
    - name: max_worker_processes
      value: '8'
    - name: max_parallel_workers
      value: '4'
    - name: effective_cache_size
      value: '3GB'
    - name: shared_buffers
      value: '1GB'
```

#### Location Service Database (PostGIS)
```sql
-- PostGIS 확장 설치 스크립트
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;
CREATE EXTENSION IF NOT EXISTS postgis_tiger_geocoder;

-- 공간 인덱스 생성
CREATE INDEX idx_places_location_gist ON places USING GIST (location);
CREATE INDEX idx_places_region_gist ON places USING GIST (region_boundary);

-- 파티셔닝 설정 (지역별)
CREATE TABLE places_asia PARTITION OF places
FOR VALUES IN ('KR', 'JP', 'CN', 'TH', 'VN');

CREATE TABLE places_europe PARTITION OF places  
FOR VALUES IN ('FR', 'IT', 'ES', 'DE', 'UK');

CREATE TABLE places_americas PARTITION OF places
FOR VALUES IN ('US', 'CA', 'MX', 'BR', 'AR');
```

### 2. 읽기 전용 복제본 구성
```yaml
# read-replica-config.yaml
readReplicas:
  - name: profile-db-read-replica
    location: Korea South  # 다른 가용성 영역
    sku:
      name: GP_Gen5_2
      capacity: 2
    
  - name: location-db-read-replica
    location: Japan East  # 글로벌 분산
    sku:
      name: GP_Gen5_2  
      capacity: 2
```

---

## 🚀 캐시 및 메시징 아키텍처

### 1. Azure Cache for Redis 구성

#### Redis Cluster 설정
```yaml
# redis-cluster.yaml
location: Korea Central
sku:
  name: Premium
  family: P
  capacity: 1  # P1 (6GB)

properties:
  # 클러스터 모드 활성화
  enableNonSslPort: false
  minimumTlsVersion: '1.2'
  
  # 지속성 설정
  rdbBackupEnabled: true
  rdbBackupFrequency: 60  # 60분마다
  rdbStorageConnectionString: DefaultEndpointsProtocol=https;AccountName=tripgenbackup;AccountKey=...
  
  # 네트워크 보안
  subnetId: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.Network/virtualNetworks/tripgen-vnet/subnets/redis-subnet
  staticIP: 10.0.2.10
  
  # 방화벽 규칙
  redisConfiguration:
    maxmemory-policy: allkeys-lru
    notify-keyspace-events: Ex
    
firewallRules:
  - name: container-apps-subnet
    startIP: 10.0.1.0
    endIP: 10.0.1.255
```

#### 캐시 키 네이밍 및 TTL 전략
```yaml
# cache-strategy.yaml
keyNaming:
  pattern: "{service}:{domain}:{id}:{version}"
  examples:
    - "profile:member:12345:v1"
    - "location:place:67890:v1"
    - "itinerary:trip:11111:v1"

ttlStrategy:
  profile:
    member: 3600        # 1시간
    trip: 1800          # 30분
    preferences: 7200   # 2시간
    
  location:
    place: 7200         # 2시간
    search: 1800        # 30분
    translation: 86400  # 24시간
    
  itinerary:
    daily: 3600         # 1시간
    route: 14400        # 4시간
    attachment: 3600    # 1시간

evictionPolicy:
  default: allkeys-lru
  
compressionStrategy:
  enabled: true
  algorithm: gzip
  threshold: 1024  # 1KB 이상 압축
```

### 2. Azure Service Bus 구성

#### 토픽 및 구독 설계
```yaml
# service-bus-config.yaml
serviceBusNamespace:
  name: tripgen-messaging
  location: Korea Central
  sku:
    name: Premium
    capacity: 1

topics:
  - name: profile-events
    maxSizeInMegabytes: 5120
    requiresDuplicateDetection: true
    subscriptions:
      - name: itinerary-service-sub
        maxDeliveryCount: 5
        lockDuration: PT30S
      - name: notification-service-sub
        maxDeliveryCount: 3
        
  - name: itinerary-events
    maxSizeInMegabytes: 5120
    subscriptions:
      - name: profile-service-sub
        maxDeliveryCount: 5
      - name: analytics-service-sub
        maxDeliveryCount: 10

queues:
  - name: ai-itinerary-generation
    maxSizeInMegabytes: 5120
    messageTimeToLive: PT1H
    lockDuration: PT5M
    maxDeliveryCount: 3
    
  - name: external-api-calls
    maxSizeInMegabytes: 1024
    messageTimeToLive: PT10M
    lockDuration: PT1M
    maxDeliveryCount: 5
```

#### 메시지 라우팅 규칙
```csharp
// MessageRouting.cs
public class MessageRoutingRules
{
    public static readonly Dictionary<string, List<string>> EventSubscriptions = new()
    {
        ["ProfileCreated"] = new[] { "itinerary-service", "notification-service" },
        ["ProfileUpdated"] = new[] { "itinerary-service" },
        ["TripCreated"] = new[] { "itinerary-service", "analytics-service" },
        ["ItineraryGenerated"] = new[] { "profile-service", "notification-service" },
        ["LocationFavorited"] = new[] { "analytics-service" }
    };
    
    public static readonly Dictionary<string, QueueConfig> QueueConfigurations = new()
    {
        ["ai-itinerary-generation"] = new QueueConfig
        {
            MaxConcurrency = 5,
            RetryPolicy = ExponentialBackoff(TimeSpan.FromSeconds(30), 3),
            DeadLetterEnabled = true
        }
    };
}
```

---

## 📊 스케일링 정책

### 1. Container Apps 스케일링

#### HTTP 기반 스케일링
```yaml
# scaling-rules.yaml
scaleRules:
  profile-service:
    - name: http-scale-rule
      http:
        metadata:
          concurrentRequests: '10'
        
  itinerary-service:
    - name: http-scale-rule
      http:
        metadata:
          concurrentRequests: '20'
    - name: service-bus-scale-rule
      azureQueue:
        queueName: ai-itinerary-generation
        queueLength: '5'
        
  location-service:
    - name: cpu-scale-rule
      custom:
        type: cpu
        metadata:
          type: Utilization
          value: '70'
    - name: memory-scale-rule
      custom:
        type: memory
        metadata:
          type: Utilization
          value: '80'
```

#### 예측적 스케일링
```yaml
# predictive-scaling.yaml
autoscaleSettings:
  - name: profile-service-autoscale
    profiles:
      - name: business-hours
        capacity:
          minimum: '2'
          maximum: '10'
          default: '3'
        recurrence:
          timeZone: Korea Standard Time
          days: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
          hours: [9]
          minutes: [0]
          
      - name: weekend-traffic
        capacity:
          minimum: '1'
          maximum: '15' 
          default: '2'
        recurrence:
          days: ['Saturday', 'Sunday']
          hours: [10]
          minutes: [0]
          
      - name: night-hours
        capacity:
          minimum: '1'
          maximum: '3'
          default: '1'
        recurrence:
          hours: [22]
          minutes: [0]
```

### 2. 데이터베이스 스케일링

#### 자동 스케일업 정책
```yaml
# database-scaling.yaml
autoscaleConfigurations:
  profileDatabase:
    enableAutomaticTuning: true
    performanceTier: 
      min: GP_Gen5_2
      max: GP_Gen5_8
    storageAutogrow: true
    
    scaleRules:
      - metric: cpu_percent
        threshold: 80
        action: scale_up
        cooldown: 300
        
      - metric: memory_percent  
        threshold: 85
        action: scale_up
        cooldown: 300
        
  itineraryDatabase:
    enableAutomaticTuning: true
    performanceTier:
      min: GP_Gen5_4  
      max: GP_Gen5_16
    
    readReplicaScaling:
      enabled: true
      minReplicas: 1
      maxReplicas: 3
      scaleUpThreshold: 70  # CPU %
```

---

## ⚡ 성능 최적화 방안

### 1. Connection Pooling 전략

#### PostgreSQL 연결 풀링
```yaml
# connection-pooling.yaml
services:
  profile-service:
    datasource:
      hikari:
        pool-name: ProfileServicePool
        maximum-pool-size: 20
        minimum-idle: 5
        connection-timeout: 20000
        idle-timeout: 300000
        max-lifetime: 1200000
        validation-timeout: 5000
        leak-detection-threshold: 60000
        
  itinerary-service:
    datasource:
      hikari:
        pool-name: ItineraryServicePool
        maximum-pool-size: 30  # 더 높은 처리량
        minimum-idle: 10
        
  location-service:
    datasource:
      hikari:
        pool-name: LocationServicePool
        maximum-pool-size: 25
        minimum-idle: 8
```

#### Redis 연결 풀링  
```yaml
# redis-connection-pool.yaml
redis:
  jedis:
    pool:
      max-active: 50
      max-idle: 20
      min-idle: 5
      max-wait: 3000ms
      test-on-borrow: true
      test-while-idle: true
  
  cluster:
    nodes:
      - tripgen-cache.redis.cache.windows.net:6380
    max-redirects: 3
    
  timeout: 2000ms
  ssl: true
```

### 2. 캐시 최적화

#### 다계층 캐시 전략
```mermaid
graph TB
    A[Client Request] --> B[API Gateway Cache]
    B --> |Cache Miss| C[Service Cache Layer]
    C --> |Cache Miss| D[Redis Cluster]  
    D --> |Cache Miss| E[Database]
    
    B --> |Cache Hit| F[Response]
    C --> |Cache Hit| F
    D --> |Cache Hit| F
    E --> |Write Through| D
    E --> |Response| F
```

#### 캐시 최적화 설정
```java
// CacheConfiguration.java
@Configuration
@EnableCaching
public class CacheConfiguration {
    
    @Bean
    @Primary
    public RedisCacheManager cacheManager(LettuceConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()))
            .disableCachingNullValues()
            .computePrefixWith(cacheName -> "tripgen:" + cacheName + ":");
            
        Map<String, RedisCacheConfiguration> cacheConfigurations = Map.of(
            "profiles", config.entryTtl(Duration.ofHours(1)),
            "trips", config.entryTtl(Duration.ofMinutes(30)), 
            "places", config.entryTtl(Duration.ofHours(2)),
            "searches", config.entryTtl(Duration.ofMinutes(15)),
            "translations", config.entryTtl(Duration.ofHours(24))
        );
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .withInitialCacheConfigurations(cacheConfigurations)
            .transactionAware()
            .build();
    }
}
```

### 3. 데이터베이스 최적화

#### 인덱스 전략
```sql
-- 프로파일 서비스 인덱스
CREATE INDEX CONCURRENTLY idx_trips_date_range ON trips USING btree (start_date, end_date);
CREATE INDEX CONCURRENTLY idx_trip_members_lookup ON trip_members USING btree (trip_id, member_id);
CREATE INDEX CONCURRENTLY idx_members_preferences ON member_preferences USING gin (preference_type);

-- 일정 서비스 인덱스  
CREATE INDEX CONCURRENTLY idx_itineraries_trip_date ON itineraries USING btree (trip_id, date);
CREATE INDEX CONCURRENTLY idx_daily_activities_time ON daily_activities USING btree (itinerary_id, start_time);
CREATE INDEX CONCURRENTLY idx_place_cache_lookup ON place_cache USING hash (place_id);

-- 장소 서비스 공간 인덱스
CREATE INDEX CONCURRENTLY idx_places_location_gist ON places USING gist (location);
CREATE INDEX CONCURRENTLY idx_places_category_region ON places USING btree (category, region_code);
CREATE INDEX CONCURRENTLY idx_reviews_place_rating ON reviews USING btree (place_id, rating DESC);
```

#### 쿼리 최적화
```sql
-- 파티셔닝 전략
CREATE TABLE itineraries_2024 PARTITION OF itineraries
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE itineraries_2025 PARTITION OF itineraries  
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

-- 머터리얼라이즈드 뷰
CREATE MATERIALIZED VIEW popular_places AS
SELECT 
    place_id,
    AVG(rating) as avg_rating,
    COUNT(*) as review_count,
    region_code
FROM reviews r 
JOIN places p ON r.place_id = p.id
WHERE r.created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY place_id, region_code
HAVING COUNT(*) >= 10
ORDER BY avg_rating DESC, review_count DESC;

CREATE UNIQUE INDEX ON popular_places (place_id);
```

---

## 📊 모니터링 및 로깅

### 1. Azure Monitor 통합

#### Application Insights 구성
```yaml
# monitoring-config.yaml
applicationInsights:
  instrumentationKey: ${AI_INSTRUMENTATION_KEY}
  connectionString: InstrumentationKey=${AI_INSTRUMENTATION_KEY};IngestionEndpoint=https://koreacentral-1.in.applicationinsights.azure.com/
  
  sampling:
    percentage: 100
    excludedTypes: Request;Dependency;Exception
    
  customMetrics:
    - name: cache_hit_ratio
      dimensions: [service, cache_type]
    - name: external_api_latency  
      dimensions: [provider, endpoint]
    - name: database_query_duration
      dimensions: [service, query_type]
      
  alerts:
    - name: high-error-rate
      metric: exceptions/count
      threshold: 10
      timeWindow: PT5M
      severity: 2
      
    - name: slow-response-time
      metric: requests/duration
      threshold: 5000
      timeWindow: PT5M
      severity: 3
```

#### 로그 쿼리 및 대시보드
```kql
# kusto-queries.kql

# 서비스별 성능 분석
requests
| where timestamp > ago(1h)
| where cloud_RoleName in ("profile-service", "itinerary-service", "location-service")
| summarize 
    RequestCount = count(),
    AvgDuration = avg(duration),
    P95Duration = percentile(duration, 95),
    SuccessRate = avg(toint(success)) * 100
  by cloud_RoleName, bin(timestamp, 5m)
| render timechart

# 캐시 히트율 분석
customMetrics
| where name == "cache_hit_ratio"
| extend service = tostring(customDimensions.service)
| extend cache_type = tostring(customDimensions.cache_type)
| summarize AvgHitRatio = avg(value) by service, cache_type, bin(timestamp, 10m)
| render timechart

# 외부 API 호출 분석
dependencies
| where type == "HTTP"
| where target contains "kakao" or target contains "google"
| summarize 
    CallCount = count(),
    AvgDuration = avg(duration),
    FailureRate = avg(toint(success == false)) * 100
  by target, bin(timestamp, 15m)
| render timechart
```

### 2. 통합 대시보드

#### Grafana 대시보드 구성
```json
{
  "dashboard": {
    "title": "TripGen Service Dashboard",
    "panels": [
      {
        "title": "Service Health Overview",
        "type": "stat",
        "targets": [
          {
            "datasource": "ApplicationInsights",
            "query": "requests | summarize SuccessRate = avg(toint(success)) * 100"
          }
        ]
      },
      {
        "title": "Request Rate by Service",
        "type": "graph", 
        "targets": [
          {
            "query": "requests | summarize RequestRate = count() by cloud_RoleName, bin(timestamp, 1m)"
          }
        ]
      },
      {
        "title": "Database Performance",
        "type": "graph",
        "targets": [
          {
            "query": "customMetrics | where name == 'database_query_duration' | summarize AvgDuration = avg(value) by customDimensions.service"
          }
        ]
      },
      {
        "title": "Cache Hit Ratio",
        "type": "singlestat",
        "targets": [
          {
            "query": "customMetrics | where name == 'cache_hit_ratio' | summarize AvgHitRatio = avg(value)"
          }
        ]
      }
    ]
  }
}
```

---

## 💰 비용 최적화

### 1. 리소스 최적화

#### 스마트 스케일링
```yaml
# cost-optimization.yaml
costOptimization:
  autoShutdown:
    enabled: true
    schedule:
      - environment: development
        shutdown: "22:00"
        startup: "08:00"
        timezone: "Korea Standard Time"
        
  reservedInstances:
    - resource: "Azure Database for PostgreSQL"
      term: "1년"
      paymentOption: "월간"
      estimatedSavings: "30%"
      
  spotInstances:
    - resource: "Container Apps Jobs" 
      workloadType: "배치 처리"
      maxPrice: "$0.05/hour"
      
taggingStrategy:
  mandatory:
    - key: "Environment"
      values: ["dev", "staging", "prod"]
    - key: "Service"  
      values: ["profile", "itinerary", "location"]
    - key: "Owner"
      values: ["team-backend", "team-frontend"]
    - key: "CostCenter"
      values: ["development", "operations"]
```

#### 사용량 기반 요금제 활용
```yaml
# usage-based-pricing.yaml
services:
  functions:
    plan: "Consumption"
    estimatedInvocations: 500000  # 월간
    estimatedCost: "$20"
    
  apiManagement:
    tier: "Developer"  # 개발용, 운영시 Standard로 업그레이드
    estimatedCalls: 1000000  # 월간
    estimatedCost: "$50"
    
  containerApps:
    pricing:
      cpu: "$0.000024/vCPU-second"
      memory: "$0.000002.5/GiB-second" 
    estimatedMonthlyCost:
      profile: "$30"
      itinerary: "$60"
      location: "$40"
```

### 2. 스토리지 계층화

#### Blob Storage 수명주기
```json
{
  "rules": [
    {
      "name": "attachment-lifecycle",
      "type": "Lifecycle",
      "definition": {
        "actions": {
          "baseBlob": {
            "tierToCool": {
              "daysAfterModificationGreaterThan": 30
            },
            "tierToArchive": {
              "daysAfterModificationGreaterThan": 90
            },
            "delete": {
              "daysAfterModificationGreaterThan": 2555
            }
          }
        },
        "filters": {
          "blobTypes": ["blockBlob"],
          "prefixMatch": ["attachments/"]
        }
      }
    }
  ]
}
```

---

## 🔒 보안 및 네트워킹

### 1. 네트워크 보안

#### Virtual Network 구성
```yaml
# network-security.yaml
virtualNetwork:
  name: tripgen-vnet
  addressPrefix: "10.0.0.0/16"
  
  subnets:
    - name: container-subnet
      addressPrefix: "10.0.1.0/24"
      serviceEndpoints:
        - Microsoft.Sql
        - Microsoft.Storage
        - Microsoft.KeyVault
        
    - name: database-subnet
      addressPrefix: "10.0.2.0/24"
      delegations:
        - Microsoft.DBforPostgreSQL/flexibleServers
        
    - name: redis-subnet
      addressPrefix: "10.0.3.0/24"
      
    - name: functions-subnet
      addressPrefix: "10.0.4.0/24"

networkSecurityGroups:
  - name: container-nsg
    securityRules:
      - name: allow-https-inbound
        protocol: Tcp
        sourcePortRange: "*"
        destinationPortRange: "443"
        sourceAddressPrefix: "*"
        destinationAddressPrefix: "VirtualNetwork"
        access: Allow
        priority: 100
        direction: Inbound
        
  - name: database-nsg  
    securityRules:
      - name: allow-postgresql
        protocol: Tcp
        sourceAddressPrefix: "10.0.1.0/24"  # Container subnet only
        destinationPortRange: "5432"
        access: Allow
        priority: 100
```

#### Private Link 구성
```yaml
# private-link.yaml
privateEndpoints:
  - name: profile-db-pe
    service: Azure Database for PostgreSQL
    subnetId: database-subnet
    privateDnsZone: privatelink.postgres.database.azure.com
    
  - name: redis-cache-pe
    service: Azure Cache for Redis
    subnetId: redis-subnet
    privateDnsZone: privatelink.redis.cache.windows.net
    
  - name: storage-pe
    service: Azure Blob Storage
    subnetId: container-subnet
    privateDnsZone: privatelink.blob.core.windows.net
```

### 2. 인증 및 권한 관리

#### Managed Identity 구성
```yaml
# managed-identity.yaml
managedIdentities:
  - name: profile-service-identity
    type: SystemAssigned
    roleAssignments:
      - scope: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.DBforPostgreSQL/flexibleServers/profile-db
        roleDefinitionId: PostgreSQL Contributor
      - scope: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.Cache/Redis/tripgen-cache
        roleDefinitionId: Redis Cache Contributor
        
  - name: itinerary-service-identity
    type: SystemAssigned
    roleAssignments:
      - scope: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.ServiceBus/namespaces/tripgen-messaging
        roleDefinitionId: Azure Service Bus Data Owner
      - scope: /subscriptions/{subscription}/resourceGroups/tripgen-rg/providers/Microsoft.Storage/storageAccounts/tripgenattachments
        roleDefinitionId: Storage Blob Data Contributor
```

#### Key Vault 통합
```yaml
# keyvault-config.yaml
keyVault:
  name: tripgen-keyvault
  location: Korea Central
  
  secrets:
    - name: kakao-api-key
      value: ${KAKAO_API_KEY}
      contentType: "API Key"
      
    - name: google-maps-api-key
      value: ${GOOGLE_API_KEY}
      contentType: "API Key"
      
    - name: profile-db-connection-string
      value: "postgresql://profileadmin@profile-db.postgres.database.azure.com:5432/profiledb?sslmode=require"
      
  certificates:
    - name: tripgen-ssl-cert
      issuer: DigiCert
      dnsNames: ["api.tripgen.com", "*.api.tripgen.com"]
      
  accessPolicies:
    - objectId: ${PROFILE_SERVICE_PRINCIPAL_ID}
      permissions:
        secrets: ["get", "list"]
    - objectId: ${FUNCTIONS_PRINCIPAL_ID}  
      permissions:
        secrets: ["get"]
        certificates: ["get"]
```

---

## 📈 SLA 및 가용성

### 1. 서비스별 SLA 정의

| 서비스 | 목표 가용성 | RTO | RPO | 모니터링 지표 |
|--------|-------------|-----|-----|---------------|
| API Gateway | 99.95% | 15분 | 5분 | 응답시간 < 500ms |
| Profile Service | 99.9% | 30분 | 15분 | 응답시간 < 200ms |
| Itinerary Service | 99.9% | 30분 | 15분 | 응답시간 < 1000ms |
| Location Service | 99.5% | 1시간 | 30분 | 응답시간 < 300ms |
| PostgreSQL | 99.99% | 1시간 | 5분 | 연결 성공률 > 99% |
| Redis Cache | 99.9% | 15분 | 즉시 | 캐시 히트율 > 80% |

### 2. 장애 복구 전략

#### 자동 복구 메커니즘
```yaml
# disaster-recovery.yaml
backupStrategy:
  databases:
    automated:
      - service: PostgreSQL
        frequency: daily
        retention: 35일
        crossRegionReplication: true
        
  storage:
    - service: Blob Storage
      replication: GRS  # Geo-Redundant Storage
      retention: 90일
      
failoverStrategy:
  primary: Korea Central
  secondary: Korea South
  
  automaticFailover:
    enabled: true
    conditions:
      - metric: availability
        threshold: "< 99%"
        duration: "5분"
      - metric: error_rate  
        threshold: "> 5%"
        duration: "3분"
        
healthChecks:
  - name: profile-service-health
    endpoint: /api/profile/health
    interval: 30s
    timeout: 5s
    
  - name: database-connectivity
    type: custom
    script: |
      pg_isready -h profile-db.postgres.database.azure.com -p 5432
    interval: 60s
```

---

## 🚀 배포 파이프라인

### 1. CI/CD 구성

#### GitHub Actions 워크플로우
```yaml
# .github/workflows/deploy.yml
name: Deploy TripGen Services
on:
  push:
    branches: [main]
    paths: 
      - 'services/**'
      - 'infrastructure/**'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [profile-service, itinerary-service, location-service]
        
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          
      - name: Build service
        run: |
          cd services/${{ matrix.service }}
          ./gradlew build -x test
          
      - name: Build Docker image
        run: |
          docker build -t tripgenregistry.azurecr.io/${{ matrix.service }}:${{ github.sha }} \
            services/${{ matrix.service }}
            
      - name: Push to ACR
        run: |
          az acr login --name tripgenregistry
          docker push tripgenregistry.azurecr.io/${{ matrix.service }}:${{ github.sha }}
          
      - name: Deploy to Container Apps
        run: |
          az containerapp update \
            --name ${{ matrix.service }} \
            --resource-group tripgen-rg \
            --image tripgenregistry.azurecr.io/${{ matrix.service }}:${{ github.sha }}
```

#### Blue-Green 배포
```yaml
# blue-green-deployment.yaml
deployment:
  strategy: blue-green
  
  blueEnvironment:
    name: tripgen-env-blue
    services:
      - name: profile-service-blue
        replicas: 3
        
  greenEnvironment:  
    name: tripgen-env-green
    services:
      - name: profile-service-green
        replicas: 3
        
  trafficSwitching:
    canaryRatio: 10  # 10% 트래픽으로 시작
    increments: [25, 50, 75, 100]  # 단계적 증가
    validationSteps:
      - healthCheck: true
        errorRateThreshold: 1%
        latencyThreshold: 500ms
        duration: 5분
```

### 2. 인프라 as Code

#### Bicep 템플릿
```bicep
// main.bicep
param location string = 'Korea Central'
param environmentName string = 'tripgen-env'

module containerAppsEnvironment 'modules/container-apps-env.bicep' = {
  name: 'container-apps-environment'
  params: {
    location: location
    environmentName: environmentName
  }
}

module profileService 'modules/profile-service.bicep' = {
  name: 'profile-service'
  params: {
    location: location
    environmentId: containerAppsEnvironment.outputs.environmentId
    databaseConnectionString: profileDatabase.outputs.connectionString
  }
  dependsOn: [
    containerAppsEnvironment
  ]
}

module profileDatabase 'modules/postgresql.bicep' = {
  name: 'profile-database'
  params: {
    location: location
    serverName: 'tripgen-profile-db'
    databaseName: 'profiledb'
    administratorLogin: 'profileadmin'
    administratorPassword: keyVault.getSecret('profile-db-password')
  }
}
```

---

## 📋 구현 체크리스트

### Phase 1: 기본 인프라 (2주)
- [ ] Azure Resource Group 및 네트워킹 설정
- [ ] Container Apps Environment 구성
- [ ] PostgreSQL 데이터베이스 3개 프로비저닝
- [ ] Redis Cache 클러스터 설정
- [ ] API Management 기본 구성

### Phase 2: 서비스 배포 (3주)
- [ ] Profile Service 컨테이너 배포
- [ ] Itinerary Service 컨테이너 배포  
- [ ] Location Service 컨테이너 배포
- [ ] MCP Proxy Functions 배포
- [ ] Service Bus 토픽/큐 구성

### Phase 3: 통합 및 최적화 (2주)
- [ ] 서비스 간 통신 테스트
- [ ] 캐시 전략 적용 및 검증
- [ ] 성능 테스트 및 튜닝
- [ ] 모니터링 대시보드 구성
- [ ] 보안 정책 적용

### Phase 4: 운영 준비 (1주)
- [ ] 자동 백업 및 복구 테스트
- [ ] 장애 시나리오 테스트
- [ ] 문서화 완료
- [ ] 팀 교육 및 인수인계

---

## 📊 예상 비용 분석

### 월간 운영 비용 (USD, 기준: 한국 중부)

| 서비스 | SKU/계층 | 예상 비용 | 비고 |
|--------|----------|-----------|------|
| **Compute** | | | |
| Container Apps (Profile) | 0.25 vCPU, 0.5Gi | $25 | 평균 2-3 인스턴스 |
| Container Apps (Itinerary) | 0.5 vCPU, 1Gi | $60 | 평균 3-5 인스턴스 |
| Container Apps (Location) | 0.25 vCPU, 0.5Gi | $30 | 평균 2-4 인스턴스 |
| Azure Functions (MCP) | Premium EP1 | $35 | 외부 API 프록시 |
| **Database** | | | |
| PostgreSQL (Profile) | GP 2 vCore, 32GB | $85 | 읽기 복제본 포함 |
| PostgreSQL (Itinerary) | GP 4 vCore, 64GB | $170 | 읽기 복제본 포함 |
| PostgreSQL (Location) | GP 2 vCore, 32GB | $85 | PostGIS 포함 |
| **Cache & Messaging** | | | |
| Azure Cache for Redis | Premium P1 (6GB) | $250 | 클러스터 구성 |
| Service Bus | Premium | $75 | 메시징 처리 |
| **Storage** | | | |
| Blob Storage | Standard | $15 | 첨부파일 저장 |
| **Networking** | | | |
| API Management | Developer | $50 | API Gateway |
| Front Door | Standard | $35 | 글로벌 로드밸런서 |
| **Monitoring** | | | |
| Application Insights | Pay-as-you-go | $25 | 모니터링 및 로깅 |
| **Total** | | **$940** | **월간 예상 비용** |

### 비용 최적화 방안
1. **예약 인스턴스**: 데이터베이스 1년 예약으로 30% 절약 → **$102 절약**
2. **개발환경 자동 종료**: 업무외 시간 종료로 40% 절약 → **$60 절약**  
3. **Spot 인스턴스**: 배치 작업에 활용으로 50% 절약 → **$20 절약**

**최적화 후 월간 비용: ~$758**

---

## ✅ 결론

본 Azure Cloud 기반 인프라 아키텍처는 다음과 같은 특징을 제공합니다:

### 🎯 주요 달성 목표
1. **고가용성**: 99.9% 이상 서비스 가용성 보장
2. **확장성**: 트래픽 증가에 따른 자동 스케일링
3. **성능**: 응답시간 < 500ms (평균)
4. **비용 효율성**: 사용량 기반 최적화로 월 $758
5. **보안**: 네트워크 격리 및 관리형 인증
6. **운영 효율성**: 완전 관리형 서비스 활용

### 🚀 차별화 포인트
- **컨테이너 + 서버리스 하이브리드**: 워크로드별 최적 컴퓨팅 선택
- **지능형 캐싱**: 다계층 캐시로 외부 API 의존성 최소화
- **자동화된 운영**: Infrastructure as Code와 CI/CD 통합
- **예측적 스케일링**: 사용 패턴 기반 사전 스케일링
- **글로벌 배포 준비**: 다중 리전 확장 가능한 설계

### 🔧 구현 준비 사항
1. **기술 스택 확정**: Spring Boot 3.2, PostgreSQL 13, Redis 7
2. **팀 역량 준비**: Azure Container Apps, Bicep IaC 기술 습득
3. **운영 체계**: 모니터링 대시보드, 장애 대응 프로세스 구축
4. **보안 인증**: Azure 보안 정책 및 컴플라이언스 검토

이 설계를 바탕으로 안정적이고 확장 가능한 여행 일정 생성 서비스를 Azure 클라우드에 성공적으로 구축할 수 있습니다.